

// ===== copiar.js =====

const fs = require("fs");
const path = require("path");

const directorio = "."; // ra√≠z del proyecto
const extensiones = [".js", ".env"]; // tipos de archivo a incluir
const salida = "codigo_completo.txt";

function listarArchivos(dir) {
  const archivos = fs.readdirSync(dir);
  let contenido = "";

  for (const archivo of archivos) {
    const ruta = path.join(dir, archivo);
    const stat = fs.statSync(ruta);

    if (stat.isDirectory() && archivo !== "node_modules") {
      contenido += listarArchivos(ruta); // recursivo
    } else if (extensiones.includes(path.extname(archivo))) {
      contenido += `\n\n// ===== ${ruta} =====\n\n`;
      contenido += fs.readFileSync(ruta, "utf-8");
    }
  }
  return contenido;
}

fs.writeFileSync(salida, listarArchivos(directorio));
console.log("‚úÖ C√≥digo exportado a", salida);


// ===== generar_hash.js =====

const bcrypt = require("bcrypt");

const password = "123456"; // puedes cambiarla si quieres

bcrypt.hash(password, 10, (err, hash) => {
  if (err) {
    console.error("‚ùå Error al generar el hash:", err);
  } else {
    console.log("‚úÖ Hash generado para la contrase√±a:", password);
    console.log(hash);
  }
});


// ===== src\app.js =====

const express = require("express");
const cors = require("cors");
require("dotenv").config();

// Importar rutas
const authRoutes = require("./routes/auth");
const usersRoutes = require("./routes/users");
const adminRoutes = require("./routes/admins");
const productosRoutes = require("./routes/productos");
const facturasRoutes = require("./routes/facturas");
const clientesRoutes = require("./routes/clientes");


const app = express();

// Middlewares
app.use(cors());
app.use(express.json());

// Rutas
app.use("/api/auth", authRoutes);
app.use("/api/users", usersRoutes);
app.use("/api/admins", adminRoutes);
app.use("/api/productos", productosRoutes);
app.use("/api/facturas", facturasRoutes);
app.use("/api/clientes", clientesRoutes);


// Servidor
app.listen(4000, () => {
  console.log("Servidor corriendo en http://localhost:4000");
});


// ===== src\config\db.js =====

const { Pool } = require("pg");
require("dotenv").config();

let pool;

if (process.env.DATABASE_URL) {
  // üåê Conexi√≥n a Neon (producci√≥n)
  pool = new Pool({
    connectionString: process.env.DATABASE_URL,
    ssl: { rejectUnauthorized: false },
  });
  console.log("üåç Conectando a base de datos Neon...");
} else {
  // üíª Conexi√≥n local
  pool = new Pool({
    user: process.env.DB_USER,
    host: process.env.DB_HOST,
    database: process.env.DB_NAME,
    password: process.env.DB_PASS,
    port: process.env.DB_PORT,
  });
  console.log("üíª Conectando a base de datos local...");
}

// ‚úÖ Prueba inmediata
pool.query("SELECT current_database(), NOW()", (err, res) => {
  if (err) {
    console.error("‚ùå Error conectando a la base de datos:", err.message);
  } else {
    console.log("‚úÖ Conectado correctamente a la base de datos:", res.rows[0].current_database);
    console.log("üïí Hora del servidor:", res.rows[0].now);
  }
});

module.exports = pool;


// ===== src\middleware\authMiddleware.js =====

const jwt = require("jsonwebtoken");

function authMiddleware(roles = []) {
  return (req, res, next) => {
    const token = req.headers["authorization"]?.split(" ")[1];
    if (!token) return res.status(401).json({ error: "Token requerido" });

    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      
      if (roles.length && !roles.includes(decoded.rol)) {
        return res.status(403).json({ error: "No autorizado" });
      }
     
      // if (roles.length && !roles.includes(decoded.rol)) {
      //   // ‚ö†Ô∏è Excepci√≥n temporal para pruebas: permitir al superadmin
      //   if (decoded.rol !== "superadmin") {
      //     return res.status(403).json({ error: "No autorizado" });
      //   }
      // }

      req.user = decoded;
      next();
    } catch (err) {
      return res.status(403).json({ error: "Token inv√°lido" });
    }
  };
}

module.exports = authMiddleware;


// ===== src\routes\admins.js =====

const express = require("express");
const bcrypt = require("bcrypt");
const pool = require("../config/db");
const authMiddleware = require("../middleware/authMiddleware");

const router = express.Router();

/**
 * üü£ Ruta: Crear nuevo negocio y su administrador
 * Solo el superadmin puede usarla.
 * - Crea primero el registro en "administradores"
 * - Luego crea el usuario "admin" vinculado a ese negocio
 */
router.post("/crear", authMiddleware(["superadmin"]), async (req, res) => {
  const { nombre_negocio, email_contacto, nombre_admin, email_admin, password_admin } = req.body;

  // Validar campos obligatorios
  if (!nombre_negocio || !email_contacto || !nombre_admin || !email_admin || !password_admin) {
    return res.status(400).json({ error: "Faltan datos obligatorios" });
  }

  try {
    // 1Ô∏è‚É£ Verificar si el negocio ya existe
    const negocioExistente = await pool.query(
      "SELECT * FROM administradores WHERE email_contacto = $1",
      [email_contacto]
    );
    if (negocioExistente.rows.length > 0) {
      return res.status(409).json({ error: "Ya existe un negocio con ese email de contacto" });
    }

    // 2Ô∏è‚É£ Crear el nuevo negocio
    const nuevoNegocio = await pool.query(
      "INSERT INTO administradores (nombre_negocio, email_contacto) VALUES ($1, $2) RETURNING id_admin",
      [nombre_negocio, email_contacto]
    );
    const id_admin = nuevoNegocio.rows[0].id_admin;

    // 3Ô∏è‚É£ Verificar si el email del admin ya existe
    const adminExistente = await pool.query(
      "SELECT * FROM usuarios WHERE email = $1",
      [email_admin]
    );
    if (adminExistente.rows.length > 0) {
      return res.status(409).json({ error: "El email del administrador ya est√° en uso" });
    }

    // 4Ô∏è‚É£ Crear hash seguro de la contrase√±a
    const password_hash = await bcrypt.hash(password_admin, 10);

    // 5Ô∏è‚É£ Insertar el usuario administrador vinculado al negocio
    await pool.query(
      "INSERT INTO usuarios (nombre, email, password_hash, rol, id_admin) VALUES ($1, $2, $3, $4, $5)",
      [nombre_admin, email_admin, password_hash, "admin", id_admin]
    );

    res.status(201).json({
      mensaje: "Negocio y administrador creados correctamente",
      negocio: {
        id_admin,
        nombre_negocio,
        email_contacto,
      },
      administrador: {
        nombre: nombre_admin,
        email: email_admin,
      },
    });
  } catch (error) {
    console.error("‚ùå Error al crear negocio y administrador:", error);
    res.status(500).json({ error: "Error interno del servidor" });
  }
});

/**
 * üìã Listar todos los administradores y negocios
 * Solo el superadmin puede ver esta informaci√≥n
 */
router.get("/", authMiddleware(["superadmin"]), async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT a.id_admin, a.nombre_negocio, a.email_contacto,
             u.nombre AS admin_nombre, u.email AS admin_email
      FROM administradores a
      LEFT JOIN usuarios u ON a.id_admin = u.id_admin AND u.rol = 'admin'
      ORDER BY a.id_admin DESC
    `);
    res.json(result.rows);
  } catch (error) {
    console.error("‚ùå Error al listar administradores:", error);
    res.status(500).json({ error: "Error al listar administradores" });
  }
});

module.exports = router;


// ===== src\routes\auth.js =====

/* 
  tenemos expres para manejar las rutas
  bcrypt para hashear las contrase√±as
  jsonwebtoken para crear tokens JWT y validar los usuarios
  pool para conectarnos a la base de datos
*/
const express = require("express");
const bcrypt = require("bcrypt");
const jwt = require("jsonwebtoken");
const pool = require("../config/db");

// creamos el router de express
const router = express.Router();


// ruta para login
router.post("/login", async (req, res) => {
  // extraemos email y password del body
  const { email, password } = req.body;

  try {

    // buscamos el usuario en la base de datos
    // si no existe, retornamos un error
    const result = await pool.query("SELECT * FROM usuarios WHERE email = $1", [email]);
    if (result.rows.length === 0) return res.status(404).json({ error: "Usuario no encontrado" });
    
    // si existe, comparamos la contrase√±a hasheada
    // si no coincide, retornamos un error
    const user = result.rows[0];
    const validPassword = await bcrypt.compare(password, user.password_hash);
    if (!validPassword) return res.status(401).json({ error: "Credenciales inv√°lidas" });

    // si todo es correcto, creamos un token JWT
    // y lo enviamos en la respuesta
    // el token expira en 7 d√≠as
    // incluimos id_usuario, rol e id_admin en el payload del token
    // para usarlos en la autenticaci√≥n y autorizaci√≥n
    const token = jwt.sign(
      { id_usuario: user.id_usuario, rol: user.rol, id_admin: user.id_admin },
      process.env.JWT_SECRET,
      { expiresIn: "7d" }
    );

    // enviamos el token y el rol en la respuesta
    // Si el usuario es admin, obtener tambi√©n el nombre del negocio
    let nombre_negocio = null;
    try {
      if (user.id_admin) {
        const adminRes = await pool.query(
          'SELECT nombre_negocio FROM administradores WHERE id_admin = $1',
          [user.id_admin]
        );
        nombre_negocio = adminRes.rows[0]?.nombre_negocio || null;
      }
    } catch (err) {
      console.error('Error obteniendo nombre de negocio:', err);
      // no bloqueamos el login por este error; devolvemos null en nombre_negocio
      nombre_negocio = null;
    }

    res.json({
      token,
      rol: user.rol,
      id_usuario: user.id_usuario,
      id_admin: user.id_admin,
      nombre: user.nombre,
      nombre_negocio
    });
    
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: "Error en login" });
  }
});





// exportamos el router
module.exports = router;


// ===== src\routes\clientes.js =====

const express = require("express");
const pool = require("../config/db");
const authMiddleware = require("../middleware/authMiddleware");

const router = express.Router();

/**
 * üü¢ Crear cliente
 * Solo pueden hacerlo admin o cajeros
 */
router.post("/crear", authMiddleware(["admin", "cajero"]), async (req, res) => {
  const { nombre, telefono, cedula, direccion } = req.body;
  const { id_admin } = req.user;

  if (!nombre) {
    return res.status(400).json({ error: "El nombre del cliente es obligatorio" });
  }

  try {
    // Si se env√≠a cedula, verificar unicidad dentro del mismo negocio
    if (cedula) {
      const existeCedula = await pool.query(
        "SELECT id_cliente FROM clientes WHERE cedula = $1 AND id_admin = $2",
        [cedula, id_admin]
      );
      if (existeCedula.rows.length > 0) {
        return res.status(409).json({ error: "La c√©dula ya est√° registrada para este negocio" });
      }
    }

    await pool.query(
      `INSERT INTO clientes (nombre, telefono, cedula, direccion, id_admin)
       VALUES ($1, $2, $3, $4, $5)`,
      [nombre, telefono || null, cedula || null, direccion || null, id_admin]
    );

    res.status(201).json({ mensaje: "Cliente registrado correctamente" });
  } catch (error) {
    console.error("‚ùå Error al registrar cliente:", error);
    res.status(500).json({ error: "Error al registrar cliente" });
  }
});

/**
 * üìã Listar clientes del negocio
 */
router.get("/", authMiddleware(["admin", "cajero"]), async (req, res) => {
  const { id_admin } = req.user;

  try {
    const result = await pool.query(
      "SELECT id_cliente, nombre, telefono, cedula, direccion, creado_en FROM clientes WHERE id_admin = $1 ORDER BY creado_en DESC",
      [id_admin]
    );
    res.json(result.rows);
  } catch (error) {
    console.error("‚ùå Error al listar clientes:", error);
    res.status(500).json({ error: "Error al listar clientes" });
  }
});

/**
 * ‚úèÔ∏è Editar cliente
 * Solo el admin del negocio puede hacerlo
 */
router.put("/:id_cliente", authMiddleware(["admin"]), async (req, res) => {
  const { id_cliente } = req.params;
  const { nombre, telefono, direccion, cedula } = req.body;
  const { id_admin } = req.user;

  try {
    // Si se proporciona cedula, asegurarse que no la tenga otro cliente del mismo negocio
    if (cedula) {
      const existe = await pool.query(
        "SELECT id_cliente FROM clientes WHERE cedula = $1 AND id_admin = $2 AND id_cliente != $3",
        [cedula, id_admin, id_cliente]
      );
      if (existe.rows.length > 0) {
        return res.status(409).json({ error: "La c√©dula ya est√° registrada en otro cliente" });
      }
    }

    const result = await pool.query(
      `UPDATE clientes 
       SET nombre = $1, telefono = $2, direccion = $3, cedula = $4
       WHERE id_cliente = $5 AND id_admin = $6`,
      [nombre, telefono, direccion, cedula || null, id_cliente, id_admin]
    );

    if (result.rowCount === 0) {
      return res.status(404).json({ error: "Cliente no encontrado o no pertenece a este negocio" });
    }

    res.json({ mensaje: "Cliente actualizado correctamente" });
  } catch (error) {
    console.error("‚ùå Error al actualizar cliente:", error);
    res.status(500).json({ error: "Error al actualizar cliente" });
  }
});

/**
 * üóëÔ∏è Eliminar cliente
 * Solo el admin puede hacerlo
 */
router.delete("/:id_cliente", authMiddleware(["admin"]), async (req, res) => {
  const { id_cliente } = req.params;
  const { id_admin } = req.user;

  try {
    const result = await pool.query(
      "DELETE FROM clientes WHERE id_cliente = $1 AND id_admin = $2",
      [id_cliente, id_admin]
    );

    if (result.rowCount === 0) {
      return res.status(404).json({ error: "Cliente no encontrado o no pertenece a este negocio" });
    }

    res.json({ mensaje: "Cliente eliminado correctamente" });
  } catch (error) {
    console.error("‚ùå Error al eliminar cliente:", error);
    res.status(500).json({ error: "Error al eliminar cliente" });
  }
});

module.exports = router;


// ===== src\routes\facturas.js =====

const express = require("express");
const pool = require("../config/db");
const authMiddleware = require("../middleware/authMiddleware");

const router = express.Router();

/**
 * üí∞ Crear una nueva factura (venta)
 * Solo pueden hacerlo los admin o cajeros
 */
router.post("/crear", authMiddleware(["admin", "cajero"]), async (req, res) => {
  const { productos, id_cliente } = req.body; // productos: [{ id_producto, cantidad }]
  const { id_usuario, id_admin } = req.user;
  // validate payload
  if (!Array.isArray(productos) || productos.length === 0) {
    return res.status(400).json({ error: "La factura debe contener al menos un producto" });
  }

  const client = await pool.connect();
  try {
    await client.query("BEGIN");

    let total = 0;
    let ganancia_total = 0; // üÜï nueva variable

    // üîπ Validar, actualizar stock y calcular ganancia
    for (const item of productos) {
      const id_producto = Number(item.id_producto);
      const cantidad = Number(item.cantidad);

      if (!Number.isFinite(id_producto) || !Number.isFinite(cantidad) || cantidad <= 0) {
        throw new Error(`Producto inv√°lido o cantidad no v√°lida (id: ${item.id_producto})`);
      }

      // Bloquear el producto durante la transacci√≥n
      const prodRes = await client.query(
        "SELECT precio, precio_compra, stock FROM productos WHERE id_producto = $1 AND id_admin = $2 FOR UPDATE",
        [id_producto, id_admin]
      );

      if (prodRes.rows.length === 0) {
        throw new Error(`Producto ${id_producto} no encontrado`);
      }

      const { precio, precio_compra, stock } = prodRes.rows[0];
      if (stock < cantidad) {
        throw new Error(`Stock insuficiente para el producto ${id_producto}`);
      }

      total += precio * cantidad;
      ganancia_total += (precio - precio_compra) * cantidad; // üÜï calcular ganancia

      // Actualizar stock
      await client.query(
        `UPDATE productos
         SET stock = stock - $1
         WHERE id_producto = $2
           AND id_admin = $3
           AND stock >= $1`,
        [cantidad, id_producto, id_admin]
      );
    }

    // üîπ Crear la factura con la ganancia incluida y devolver fecha
    const facturaResult = await client.query(
      "INSERT INTO facturas (id_cliente, id_usuario, id_admin, total, ganancia) VALUES ($1, $2, $3, $4, $5) RETURNING id_factura, fecha",
      [id_cliente || null, id_usuario || null, id_admin, total, ganancia_total]
    );

    const id_factura = facturaResult.rows[0].id_factura;
    const fechaFactura = facturaResult.rows[0].fecha;

    // üîπ Insertar los detalles
    for (const item of productos) {
      const id_producto = Number(item.id_producto);
      const cantidad = Number(item.cantidad);
      const precioRes = await client.query(
        "SELECT precio FROM productos WHERE id_producto = $1 AND id_admin = $2",
        [id_producto, id_admin]
      );
      const precio_unitario = precioRes.rows[0].precio;

      await client.query(
        "INSERT INTO detalle_factura (id_factura, id_producto, cantidad, precio_unitario) VALUES ($1, $2, $3, $4)",
        [id_factura, id_producto, cantidad, precio_unitario]
      );
    }

    // Obtener nombre del cliente (si existe) y nombre del vendedor
    let clienteNombre = null;
    if (id_cliente) {
      const cRes = await client.query("SELECT nombre FROM clientes WHERE id_cliente = $1 AND id_admin = $2", [id_cliente, id_admin]);
      if (cRes.rows.length) clienteNombre = cRes.rows[0].nombre;
    }

    let vendedorNombre = null;
    if (id_usuario) {
      const vRes = await client.query("SELECT nombre FROM usuarios WHERE id_usuario = $1", [id_usuario]);
      if (vRes.rows.length) vendedorNombre = vRes.rows[0].nombre;
    }

    await client.query("COMMIT");

    res.status(201).json({
      mensaje: "Factura registrada correctamente",
      id_factura,
      fecha: fechaFactura,
      total,
      cliente: clienteNombre || 'Sin cliente',
      vendedor: vendedorNombre,
      ganancia_total
    });
  } catch (error) {
    await client.query("ROLLBACK");
    console.error("‚ùå Error al crear factura:", error);
    res.status(500).json({ error: error.message });
  } finally {
    client.release();
  }
});


// üìã Listar todas las facturas
router.get("/", authMiddleware(["admin", "superadmin", "cajero", "vendedor"]), async (req, res) => {
  const { id_admin, rol, id_usuario } = req.user;

  try {
    let query = `
      SELECT f.id_factura, f.fecha, f.total,
             COALESCE(c.nombre, 'Sin cliente') AS cliente,
             u.nombre AS vendedor
      FROM facturas f
      LEFT JOIN clientes c ON f.id_cliente = c.id_cliente
      LEFT JOIN usuarios u ON f.id_usuario = u.id_usuario
      WHERE f.id_admin = $1
      ORDER BY f.fecha DESC
    `;
    let params = [id_admin];

    if (rol === "cajero" || rol === "vendedor") {
      query = `
        SELECT f.id_factura, f.fecha, f.total,
               COALESCE(c.nombre, 'Sin cliente') AS cliente,
               u.nombre AS vendedor
        FROM facturas f
        LEFT JOIN clientes c ON f.id_cliente = c.id_cliente
        LEFT JOIN usuarios u ON f.id_usuario = u.id_usuario
        WHERE f.id_admin = $1 AND f.id_usuario = $2
        ORDER BY f.fecha DESC
      `;
      params = [id_admin, id_usuario];
    }

    const facturasRes = await pool.query(query, params);
    res.json(facturasRes.rows);
  } catch (error) {
    console.error("‚ùå Error al listar facturas:", error);
    res.status(500).json({ error: "Error al listar facturas" });
  }
});




/**
 * üìã Listar facturas del negocio
 * Solo el admin puede verlas
 */
router.get("/:id_factura", authMiddleware(["admin", "cajero"]), async (req, res) => {
  const { id_factura } = req.params;
  const { id_admin, rol, id_usuario } = req.user;

  try {
    const facturaRes = await pool.query(
      `SELECT f.id_factura, f.fecha, f.total, f.id_usuario,
              COALESCE(c.nombre, 'Sin cliente') AS cliente,
              u.nombre AS vendedor
       FROM facturas f
       LEFT JOIN clientes c ON f.id_cliente = c.id_cliente
       LEFT JOIN usuarios u ON f.id_usuario = u.id_usuario
       WHERE f.id_factura = $1 AND f.id_admin = $2`,
      [id_factura, id_admin]
    );

    if (facturaRes.rows.length === 0) {
      return res.status(404).json({ error: "Factura no encontrada o no pertenece a este negocio" });
    }

    const factura = facturaRes.rows[0];

    // ‚úÖ Comparaci√≥n por ID real, no por nombre
    if (rol === "cajero" && factura.id_usuario !== id_usuario) {
      return res.status(403).json({ error: "No autorizado para ver esta factura" });
    }

    const detallesRes = await pool.query(
      `SELECT p.nombre, d.cantidad, d.precio_unitario, (d.precio_unitario * d.cantidad) AS subtotal
       FROM detalle_factura d
       INNER JOIN productos p ON d.id_producto = p.id_producto
       WHERE d.id_factura = $1`,
      [id_factura]
    );

    res.json({
      factura: {
        id_factura: factura.id_factura,
        cliente: factura.cliente,
        vendedor: factura.vendedor,
        fecha: factura.fecha,
        total: factura.total,
        productos: detallesRes.rows,
      },
    });
  } catch (error) {
    console.error("‚ùå Error al obtener factura:", error);
    res.status(500).json({ error: "Error al obtener factura" });
  }
});


// üóëÔ∏è Eliminar factura (admin o superadmin)
router.delete("/:id_factura", authMiddleware(["admin", "superadmin"]), async (req, res) => {
  const { id_factura } = req.params;
  const { id_admin, rol } = req.user;

  const client = await pool.connect();
  try {
    await client.query('BEGIN');

    // Verificar existencia
    const fRes = await client.query('SELECT id_factura FROM facturas WHERE id_factura = $1 AND id_admin = $2', [id_factura, id_admin]);
    if (fRes.rows.length === 0) {
      // si es superadmin, permitir eliminar sin filtrar por id_admin
      if (rol === 'superadmin') {
        const fAll = await client.query('SELECT id_factura FROM facturas WHERE id_factura = $1', [id_factura]);
        if (fAll.rows.length === 0) {
          await client.query('ROLLBACK');
          return res.status(404).json({ error: 'Factura no encontrada' });
        }
      } else {
        await client.query('ROLLBACK');
        return res.status(404).json({ error: 'Factura no encontrada o no pertenece a este negocio' });
      }
    }

    // Restaurar stock: obtener detalles y sumar las cantidades
    // Obtener id_admin de la factura (si no se obtuvo antes)
    let facturaAdminId = id_admin;
    if (!facturaAdminId) {
      const fAll = await client.query('SELECT id_admin FROM facturas WHERE id_factura = $1', [id_factura]);
      facturaAdminId = fAll.rows[0]?.id_admin || null;
    }

    const detalles = await client.query('SELECT id_producto, cantidad FROM detalle_factura WHERE id_factura = $1', [id_factura]);
    for (const d of detalles.rows) {
      // Restaurar stock solo si el producto pertenece al mismo id_admin de la factura
      await client.query('UPDATE productos SET stock = stock + $1 WHERE id_producto = $2 AND id_admin = $3', [d.cantidad, d.id_producto, facturaAdminId]);
    }

    // Borrar detalles y factura
    await client.query('DELETE FROM detalle_factura WHERE id_factura = $1', [id_factura]);
    await client.query('DELETE FROM facturas WHERE id_factura = $1', [id_factura]);

    await client.query('COMMIT');
    res.json({ mensaje: 'Factura eliminada correctamente', id_factura });
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('‚ùå Error al eliminar factura:', error);
    res.status(500).json({ error: 'Error al eliminar factura' });
  } finally {
    client.release();
  }
});



module.exports = router;


// ===== src\routes\productos.js =====

const express = require("express");
const pool = require("../config/db");
const authMiddleware = require("../middleware/authMiddleware");

const router = express.Router();

/**
 * üü¢ Crear producto (solo admin)
 */
router.post("/crear", authMiddleware(["admin"]), async (req, res) => {
  const { nombre, precio, stock, precio_compra } = req.body;
  const id_admin = req.user.id_admin; // viene del token JWT

  // Normalizar valores num√©ricos
  const precioNum = Number(precio);
  const precioCompraNum = precio_compra !== undefined && precio_compra !== null ? Number(precio_compra) : 0;
  const stockNum = stock !== undefined && stock !== null ? Number(stock) : 0;

  if (!nombre || isNaN(precioNum)) {
    return res.status(400).json({ error: "El nombre y el precio son obligatorios y deben ser num√©ricos" });
  }

  try {
    await pool.query(
      "INSERT INTO productos (nombre, precio, precio_compra, stock, id_admin) VALUES ($1, $2, $3, $4, $5)",
      [nombre, precioNum, precioCompraNum || 0, stockNum || 0, id_admin]
    );

    res.status(201).json({ mensaje: "Producto creado correctamente" });
  } catch (error) {
    console.error("‚ùå Error al crear producto:", error);
    res.status(500).json({ error: "Error al crear producto" });
  }
});

/**
 * üîπ Listar productos (admin, cajero o vendedor)
 */
router.get("/", authMiddleware(["admin", "cajero", "vendedor"]), async (req, res) => {
  const id_admin = req.user.id_admin;

  try {
    const result = await pool.query(
      "SELECT * FROM productos WHERE id_admin = $1 ORDER BY id_producto DESC",
      [id_admin]
    );
    res.json(result.rows);
  } catch (error) {
    console.error("‚ùå Error al listar productos:", error);
    res.status(500).json({ error: "Error al listar productos" });
  }
});

/**
 * ‚úèÔ∏è Editar producto (solo admin)
 */
router.put("/:id", authMiddleware(["admin"]), async (req, res) => {
  const { id } = req.params;
  const { nombre, precio, stock } = req.body;
  const id_admin = req.user.id_admin;

  try {
    const result = await pool.query(
      "UPDATE productos SET nombre = $1, precio = $2, stock = $3 WHERE id_producto = $4 AND id_admin = $5",
      [nombre, precio, stock, id, id_admin]
    );

    if (result.rowCount === 0) {
      return res.status(404).json({ error: "Producto no encontrado o no pertenece a este negocio" });
    }

    res.json({ mensaje: "Producto actualizado correctamente" });
  } catch (error) {
    console.error("‚ùå Error al actualizar producto:", error);
    res.status(500).json({ error: "Error al actualizar producto" });
  }
});



/**
 * ‚ûï A√±adir existencias a un producto (solo admin)
 */
router.put("/:id/anadir-stock", authMiddleware(["admin"]), async (req, res) => {
  const { id } = req.params;
  const { cantidad } = req.body;
  const id_admin = req.user.id_admin;

  if (!cantidad || cantidad <= 0) {
    return res.status(400).json({ error: "La cantidad debe ser mayor a 0" });
  }

  try {
    const result = await pool.query(
      `UPDATE productos 
       SET stock = stock + $1 
       WHERE id_producto = $2 AND id_admin = $3 
       RETURNING *`,
      [cantidad, id, id_admin]
    );

    if (result.rowCount === 0) {
      return res.status(404).json({ error: "Producto no encontrado o no pertenece a este negocio" });
    }

    res.json({
      mensaje: `Se anadieron ${cantidad} unidades al producto "${result.rows[0].nombre}"`,
      producto: result.rows[0],
    });
  } catch (error) {
    console.error("‚ùå Error al anadir stock:", error);
    res.status(500).json({ error: "Error al a√±adir stock" });
  }
});


/**
 * üóëÔ∏è Eliminar producto (solo admin)
 */
router.delete("/:id", authMiddleware(["admin"]), async (req, res) => {
  const { id } = req.params;
  const id_admin = req.user.id_admin;

  try {
    const result = await pool.query(
      "DELETE FROM productos WHERE id_producto = $1 AND id_admin = $2",
      [id, id_admin]
    );

    if (result.rowCount === 0) {
      return res.status(404).json({ error: "Producto no encontrado o no pertenece a este negocio" });
    }

    res.json({ mensaje: "Producto eliminado correctamente" });
  } catch (error) {
    console.error("‚ùå Error al eliminar producto:", error);
    res.status(500).json({ error: "Error al eliminar producto" });
  }
});

module.exports = router;


// ===== src\routes\users.js =====

// src/routes/usuarios.js
const express = require("express");
const bcrypt = require("bcrypt");
const pool = require("../config/db");
const authMiddleware = require("../middleware/authMiddleware");

const router = express.Router();

// üü¢ Crear cajero o vendedor (solo para admin)
router.post("/crear", authMiddleware(["admin"]), async (req, res) => {
  const { nombre, email, password, rol } = req.body;
  const id_admin = req.user.id_admin;

  // Solo se permiten roles de empleados
  const rolesPermitidos = ["cajero", "vendedor"];
  if (!rolesPermitidos.includes(rol)) {
    return res.status(403).json({ error: "Rol no permitido" });
  }

   if (!nombre || !email || !password || !rol) {
    return res.status(400).json({ error: "Faltan datos obligatorios" });
  }
  try {
    const existe = await pool.query("SELECT * FROM usuarios WHERE email = $1", [email]);
    if (existe.rows.length > 0) {
      return res.status(409).json({ error: "El email ya est√° registrado" });
    }

    const password_hash = await bcrypt.hash(password, 10);

    // id_admin viene del token del admin logueado
   

    await pool.query(
      "INSERT INTO usuarios (nombre, email, password_hash, rol, id_admin) VALUES ($1, $2, $3, $4, $5)",
      [nombre, email, password_hash, rol, id_admin]
    );

    res.status(201).json({ mensaje: "Empleado creado correctamente" });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: "Error al crear empleado" });
  }
});

// ‚ûï Editar empleado (nombre, email, rol o contrase√±a)
router.put("/:id_usuario", authMiddleware(["admin"]), async (req, res) => {
  const { id_usuario } = req.params;
  const { nombre, email, password, rol } = req.body;
  const id_admin = req.user.id_admin;

  try {
    // Verificar si pertenece a su negocio
    const existe = await pool.query(
      "SELECT * FROM usuarios WHERE id_usuario = $1 AND id_admin = $2",
      [id_usuario, id_admin]
    );
    if (existe.rows.length === 0) {
      return res.status(404).json({ error: "Empleado no pertenece a este negocio" });
    }

    // Hash opcional de contrase√±a
    let password_hash = existe.rows[0].password_hash;
    if (password) password_hash = await bcrypt.hash(password, 10);

    await pool.query(
      `UPDATE usuarios SET nombre = $1, email = $2, password_hash = $3, rol = $4 
       WHERE id_usuario = $5 AND id_admin = $6`,
      [nombre, email, password_hash, rol, id_usuario, id_admin]
    );

    res.json({ mensaje: "Empleado actualizado correctamente" });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Error al actualizar empleado" });
  }
});

// üóëÔ∏è Eliminar empleado
router.delete("/:id_usuario", authMiddleware(["admin"]), async (req, res) => {
  const { id_usuario } = req.params;
  const id_admin = req.user.id_admin;

  try {
    const result = await pool.query(
      "DELETE FROM usuarios WHERE id_usuario = $1 AND id_admin = $2",
      [id_usuario, id_admin]
    );

    if (result.rowCount === 0) {
      return res.status(404).json({ error: "Empleado no encontrado o no pertenece a este negocio" });
    }
    res.json({ mensaje: "Empleado eliminado correctamente" });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Error al eliminar empleado" });
  }
});



/**
 * üìã Listar empleados (cajeros y vendedores) del negocio del admin
 */
router.get("/", authMiddleware(["admin"]), async (req, res) => {
  const id_admin = req.user.id_admin;

  try {
    const result = await pool.query(
      "SELECT id_usuario, nombre, email, rol FROM usuarios WHERE id_admin = $1 AND rol IN ('cajero', 'vendedor') ORDER BY id_usuario DESC",
      [id_admin]
    );
    res.json(result.rows);
  } catch (error) {
    console.error("‚ùå Error al listar empleados:", error);
    res.status(500).json({ error: "Error al listar empleados" });
  }
});


module.exports = router;
